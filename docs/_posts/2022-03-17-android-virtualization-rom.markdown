---
layout: post
title:  "Virtualizacion a nivel de plataforma en Dispositivo Android"
date:   2022-03-17 07:19:16 +0000
categories: virtualization android
---

**Palabras Claves:** KVM, AOSP, Linux Kernel, QEMU, CrosVM, Cuttlefish device, Cross-Compile, Virtualizacion anidada.

<p style="text-align:justify;"><b>Abstracto:</b> Durante las últimas décadas se ha vuelto popular el uso de tecnologías basadas en la virtualización, esto debido a las diversas ventajas que surgen al distribuir las funciones de una máquina física entre varios usuarios o entornos. Entre estas ventajas destacan el aprovechamiento de toda la capacidad de la máquina, la creación de entornos aislados, personalizados y seguros, la división independiente de tareas para mejorar la eficiencia, sin mencionar que se considera a la virtualización como la base de tecnologías basadas en la nube (Cloud Computing). Una de las tecnologías que posibilitan la virtualización son los hipervisores, los cuales son un tipo de software que separa los recursos físicos de los entornos virtuales que los necesitan, posteriormente dichos recursos los dividen de manera tal que los entornos virtuales puedan utilizarlos. La mayoría de empresas hacen uso de virtualización con hipervisores para controlar Sistemas Operativos o para instalarse directamente en el hardware. Uno de los hipervisores mayormente utilizados en la actualidad es KVM (Máquina Virtual basada en Kernel) el cual es Open Source y se encuentra integrado en el Kernel de Linux desde la versión 2.6 en adelante. Teniendo en cuenta que el Sistema Operativo Android para dispositivos móviles utiliza como base el kernel de linux, se puede pensar que este mismo hipervisor KVM puede ser utilizado para implementar servicios basados en virtualización utilizando como host plataformas móviles. Por tanto, en la presente investigación se pretende exponer conceptos, teoría y experimentos que permitan una virtualización a nivel de plataforma en un dispositivo móvil, con enfoque al uso del hipervisor KVM en Sistemas Operativos Android. Posteriormente se utilizan las máquinas virtuales para exponer aplicaciones reales que son de beneficio para uso cotidiano y empresarial.</p>
<br><br>

<h2 style="text-align:center;">INTRODUCCION</h2>
<p style="text-align:justify;">El crecimiento de las plataformas y dispositivos móviles durante la última década es exponencial. Para nosotros es fácil percibirlo teniendo en cuenta que forman parte de nuestro dia a dia, siendo estos de utilidad ya sea para aplicaciones cotidianas en materia de comunicación, planificación y entretenimiento; así como aplicaciones empresariales en materia de Marketing, Ventas, Organización, Análisis y resultados científicos entre otros. Los dispositivos móviles están en todas partes del mundo y en cada actividad que realizamos, por esa razón se dice que existe una aplicación móvil para todo. Es importante tener en cuenta que así como crecen los diversos campos de la ciencia de la misma forma cada día se desarrollan aplicaciones que requieren una mayor complejidad tanto lógica a nivel de software como física a nivel de hardware. Teniendo lo anterior en cuenta no es de extrañar que cada ciertos meses o años veamos surgir nuevas gamas de dispositivos con caracteristicas nuevas y en algunos casos con mayor potencia tecnica en comparacion a sus antecesores.</p>

<p style="text-align:justify;">Todas estas ventajas ofrecidas por los dispositivos móviles son en parte gracias al constante desarrollo de diversos Sistemas Operativos. Un Sistema Operativo es el programa más importante que se ejecuta en una computadora. Este se encarga de administrar procesos, memoria así como a otros programas y al hardware en general. También permite comunicarnos con una computadora sin la necesidad de saber el lenguaje de máquina. Es importante entender que un dispositivo móvil es como tal considerado una computadora, de hecho, todo software destinado para computadoras de escritorio, portátiles o servidores, sin duda alguna, puede ser programado para dispositivos móviles, la única diferencia está en las capacidades a nivel de hardware. En la actualidad destacan dos grandes Sistemas Operativos para dispositivos móviles, nos referimos al Sistema Operativo Android propiedad del gigante Google inc company y al Sistema Operativo Iphone de Apple inc company. Es improtante mencionar que los conceptos y prácticas en este artículo son realizadas con base al Sistema Operativo Android. Esto debido a que Android OS es un sistema de código abierto, por lo cual es de acceso libre para todos e incluso para uso comercial. Sin mencionar que Android OS por mucho es el Sistema Operativo más popular alrededor del mundo. Teniendo en cuenta que la base de Android OS es el kernel de linux esto permite que sea un sistema operativo multiplataforma ya que su implementación no se limita solamente a dispositivos móviles, por lo cual se abre una mayor variedad de posibilidades en comparación a otros Sistemas Operativos moviles.</p>

<br>
<h3>Android Open Source Project (AOSP)</h3>
<p style="text-align:justify;">Android es una pila de software de código abierto creada para una amplia gama de dispositivos con diferentes factores de forma. El objetivo principal de Android es crear una plataforma de software abierta disponible para operadores, fabricantes de equipos originales y desarrolladores para hacer realidad sus ideas innovadoras y presentar un producto exitoso del mundo real que mejore la experiencia móvil de los usuarios. Android está diseñado para que no haya un punto central de falla, donde un actor de la industria restringe o controla las innovaciones de otro. El resultado es un producto de consumo completo con calidad de producción con código fuente abierto para la personalización y la migración. En primer lugar, la filosofía de Android es pragmática. El objetivo es un producto compartido que cada colaborador pueda adaptar y personalizar. Por supuesto, la personalización descontrolada puede dar lugar a implementaciones incompatibles. Para evitar esto, el Proyecto de código abierto de Android (AOSP) mantiene el Programa de compatibilidad de Android, que explica en detalle lo que significa ser compatible con Android y lo que se requiere de los fabricantes de dispositivos para lograr ese estado. Cualquiera puede usar el código fuente de Android para cualquier propósito y todos los usos legítimos son bienvenidos. <a href="https://source.android.com/setup/intro">[1]</a></p>

<p style="text-align:justify;">El proyecto de código abierto AOSP permite a los desarrolladores estudiar y experimentar a fondo las distintas versiones de Android mediante un conjunto de repositorios que son identificados por etiquetas las cuales hacen referencia a la versión de Android a la que van destinados. Por ejemplo, suponiendo tal vez que por razones de capacidad o consumo, tu equipo de desarrollo está interesado en la implementación de sistemas utilizando Android 9 (pie), siendo esto cierto, es probable que tu equipo opte por utilizar la rama aosp-pie-gsi aunque existen diversas ramas relacionadas a una misma versión de Android pero con propósitos diferentes. Es importante mencionar que para trabajar con el código de estos repositorios, es requisito utilizar el sistema de control de versiones Git así como Repo, una herramienta administradora de repositorios desarrollada por Google y que trabaja sobre Git. Cada repositorio cuenta con un conjunto de herramientas que permiten la compilación y emulación de dispositivos Android. Por defecto AOSP nos proporciona el código fuente del kernel y las especificaciones binarias para poder compilar algunos dispositivos específicos tales como Nexus y Pixel. También podemos crear compilaciones para placas tales como DragonBoard 845c, HiKey 960, Khadas VIM3 y Qualcomm Robotics Board RB5. Otra opción que AOSP nos proporciona en cuanto a la compilación de dispositivos es el uso de Imágenes de Sistema Genérico (GSI) la cual se ajusta a las configuraciones de dispositivos Android. En caso de que contemos con el código fuente (kernel) de algún dispositivo Android que no se encuentra en la lista del repositorio, AOSP nos brinda las herramientas necesarias para poder agregar un nuevo dispositivo, por ejemplo un Xperia Z, dispositivo sobre el cual precisamente existe una documentación de cómo compilarlo utilizando AOSP mediante el código fuente de uso abierto proporcionado por Sony. Por último se hace mención a los dispositivos Cuttlefish, un tipo de dispositivo agregado desde la versión 9 de Android hasta la actualidad y que ofrece una gran variedad de ventajas en comparación a otros tipos de dispositivos, como por ejemplo el tipo de emulación que lo caracteriza. Cuttlefish es un dispositivo Android virtual configurable que puede ejecutarse tanto de forma remota (usando ofertas de nube de terceros como Google Cloud Engine) como localmente (en máquinas Linux x86). Cuttlefish garantiza la fidelidad total con el marco de trabajo de Android (ya sea AOSP puro o una implementación personalizada en nuestro propio árbol). En la aplicación del mundo real, esto significa que debemos esperar que Cuttlefish responda a interacciones en el nivel del sistema operativo tal cual como lo haría un teléfono físico creado con la misma fuente de sistema operativo Android pura o personalizada. Para las prácticas realizadas en este artículo se utiliza un dispositivo Cuttlefish de la rama gsi de Android 11, en específico, el dispositivo <code>aosp_cf_x86_phone</code> perteneciente a la rama <code>aosp-android11-gsi</code>.
</p><br>
<h4>Capas de compilacion</h4>
<p style="text-align:justify;">La jerarquía de compilación incluye capas de abstracción que corresponden a la composición física de un dispositivo: <a href="https://source.android.com/setup/develop/new-device#build-layers">[2]</a></p>
- **La capa del producto** define la especificación de funciones de un producto de envío, como los módulos que se van a construir, las configuraciones regionales admitidas y la configuración para varias configuraciones regionales. En otras palabras, este es el nombre del producto en general. Las variables específicas del producto se definen en archivos MAKE de definición de producto. Entre algunos ejemplos tenemos a ```myProduct```, ```myProduct_eu```, ```myProduct_eu_fr```, ```j2```, ```sdk```.
- **La capa de placa/dispositivo** representa la capa física de plástico en el dispositivo (es decir, el diseño industrial del dispositivo). Esta capa también representa los esquemas básicos de un producto. Estos incluyen los periféricos en la placa y su configuración. Los nombres utilizados son simplemente códigos para diferentes configuraciones de placa/dispositivo. Entre algunos ejemplos tenemos a ```marlin```, ```blueline```, ```coral```.
- **La capa de arquitectura** describe la configuración del procesador y la interfaz binaria de la aplicación (ABI) que se ejecutan en la placa. Entre algunos ejemplos tenemos a ```arm```, ```x86```, ```arm64```, ```x86_64```.

<br>
<h4>Sistema de compilacion</h4>
<p style="text-align:justify;">Es importante mencionar que en los repositorios AOSP nos podemos encontrar con dos sistemas de compilación diferentes. El primero es GNU Make, una herramienta la cual controla la generación de ejecutables y otros programas que no pertenecen al código fuente pero que si son requeridos por otros archivos fuentes. GNU Make compila los programas a partir de un archivo llamado makefile, que enumera cada uno de los archivos que no son fuente y los procesa a partir de otros archivos. El sistema de compilación GNU Make lo encontramos en versiones anteriores a Android 7 dentro del proyecto AOSP. El segundo es Soong, introducido a partir de Android 7.0 (Nougat) para reemplazar a make. Aprovecha la herramienta de clonación Kati GNU Make y el componente del sistema de compilación Ninja para acelerar las compilaciones de Android. Soong es el reemplazo del antiguo sistema de compilación basado en make de Android. Reemplaza los archivos Android.mk con archivos Android.bp, que son descripciones declarativas simples similares a JSON de los módulos para compilar. Hacer distinción entre ambos tipos de sistemas es clave en caso de que se desee implementar un marco de trabajo personalizado, otra razón a tener en cuenta es la diferencia en el consumo de recursos que requiere cada sistema. De una forma empírica y basándonos en los experimentos realizados por el equipo de trabajo, se confirmó que las últimas versiones en AOSP (7 en adelante) tienden a consumir mas del doble de recursos que sus antecesoras, esto en parte debido al sistema de compilado, por ejemplo, la rama master (ultima estable) publicada hasta el momento, hace referencia a Android 13 (tiramisu) sobre la cual se confirmó un consumo por encima de los 12GB de ram durante el proceso de compilado; Una notable diferencia en comparación al compilado de la versión 7.1.2 (Nougat) de la cual se registró un consumo por debajo de los 4GB de ram.</p>

<br>
<h4>Tipos de Emuladores</h4>
<p>Actualmente en AOSP destacan dos formas de emular dispositivos android; La forma mas comun es por medio de un Emulador Android de Dispositivos Virtuales (AVD). Android Emulator nos permite ejecutar emulaciones de dispositivos Android en máquinas con Windows, macOS o Linux. El emulador de Android ejecuta el sistema operativo Android en una máquina virtual llamada dispositivo virtual de Android (AVD). El AVD contiene una pila completa de software de Android y se ejecuta como si estuviera en un dispositivo físico. <a href="https://source.android.com/setup/create/avd">[3]</a></p>
<p style="text-align:center;">Figura 1</p>
<img src="https://raw.githubusercontent.com/martulioruiz/my_blog/main/docs/assets/emulator-design.png" style="display: block; margin-left: auto; margin-right: auto; width: 50%;">
<p style="text-align:center; "><i>Nota. Arquitectura AVD, (s. f.). Android Open Source Project.</i></p>
<p style="text-align:justify;">La segunda forma es por medio de Dispositivos Virtuales Android Cuttlefish (CVD), como se menciono anteriormente Cuttlefish es un dispositivo Android virtual configurable que puede ejecutarse tanto de forma remota (usando ofertas de nube de terceros como Google Cloud Engine) como localmente (en máquinas Linux x86). Hay muchas similitudes con el emulador de Android, pero Cuttlefish garantiza una fidelidad total con el marco de trabajo de Android (ya sea AOSP puro o una implementación personalizada en su propio árbol). En la aplicación del mundo real, esto significa que debemos esperar que Cuttlefish responda a sus interacciones en el nivel del sistema operativo como un objetivo de teléfono físico creado con la misma fuente de sistema operativo Android pura o personalizada. El emulador de Android se ha creado en torno al caso de uso de facilitar el desarrollo de aplicaciones y contiene muchos ganchos funcionales para atraer los casos de uso del desarrollador de aplicaciones de Android. Esto puede presentar desafíos si el objetivo es crear un emulador con marco de Android personalizado. Para los casos en que se  necesita un dispositivo virtual que sea representativo para una plataforma/código de marco personalizado o arbol de Android, entonces Cuttlefish es una opción virtual ideal. Es el dispositivo canónico para representar el estado actual del desarrollo de AOSP. Uno de los aspectos importantes a destacar sobre los dispositivos cuttlefish es que son dispositivos Android que pueden ser utilizados para depurar. Se pueden registrar a si mismos como un dispositvo normal via ADB y se puede interactuar con ellos como si fuesen un dispositivo fisico por medio de Escritorios remotos.<a href="https://source.android.com/setup/create/cuttlefish">[4]</a></p>
<p style="text-align:center;">Figura 2</p>
<img src="https://raw.githubusercontent.com/martulioruiz/my_blog/main/docs/assets/cf.png" style="display: block; margin-left: auto; margin-right: auto; width: 50%;">
<p style="text-align:center; "><i>Nota. Dispositivo Virtual Cuttlefish renderizado via Webrt.</i></p>
<br>
<h4>Integracion Continua de Android</h4>
<p style="text-align:justify;">Teniendo en cuenta que el equipo de desarrollo se centró en realizar pruebas principalmente en el dispositivo virtual Cuttlefish <code>aosp_cf_x86_phone</code> perteneciente a la rama <code>aosp-android11-gsi</code> consideramos importante mencionar el procedimiento que se siguió para escoger este dispositivo en particular entre una gran variedad de opciones disponibles; Si bien, la idea principal era compilar un dispositivo perteneciente a la última versión de Android y emularlo. Pero a pesar de que se logró compilar con éxito este no se logró emular correctamente. La razón del fallo era que se estaba intentado emular localmente un dispositivo cuttlefish de arquitectura x86_64 y como sabemos tomando de referencia la documentación oficial de AOSP, localmente solamente son soportados los dispositivos de arquitectura x86. Este descubrimiento se logró luego de muchas compilaciones de diferentes dispositivos al azar, tanto de la rama master así como de otras ramas. Como consecuencia se consumió una gran cantidad de tiempo en lo que se esperaba a que terminara de compilarse cada dispositivo. Además de la arquitectura se encontraron otras razones por las cuales algunos dispositivos en específico no se lograban emulaban con éxito, la mayoría de estos problemas estaban relacionados con requisitos e incompatibilidades de hardware en el sistema operativo host. Teniendo en cuenta lo anterior se podría decir que era una tarea tediosa encontrar dispositivos que funcionaran correctamente en la máquina host de cada integrante del equipo, principalmente debido a que el compilado tardaba horas en finalizar. Afortunadamente Google nos proporciona una solución de integración continua (Android CI) que nos permite tener acceso a distintos artefactos de dispositivos ya compilados. Entre  estos artefactos se encuentran archivos de imágenes y herramientas de host cuttlefish necesarios para una correcta emulación. Si bien estos artefactos se generaban al compilar los dispositivos, mediante Android CI se lograban obtener en cuestión de minutos dependiendo de la velocidad de descarga de nuestro internet. Por tanto mediante Android CI se obtuvieron los artefactos de diversos dispositivos cuttlefish y estos posteriormente se utilizaron para realizar pruebas hasta encontrar el dispositivo que mejor se ajustaba a nuestro entorno, resultando como mejor opción el dispositivo aosp_cf_x86_phone de la rama aosp-android11-gsi.
</p>


<br><br>
<h2 style="text-align:center;">BIBLIOGRAFIAS</h2>
1. Set up for Android Development. | (s. f.). Android Open Source Project. |<a href="https://source.android.com/setup/intro">Enlace a la pagina</a>
2. Adding a New Device.|(s. f.). Android Open Source Project.|<a href="https://source.android.com/setup/develop/new-device#build-layers">Enlace a la pagina</a> 
3. Using Android Emulator Virtual Devices.| (s. f.). Android Open Source Project.|<a href="https://source.android.com/setup/create/avd">Enlace a la pagina</a>
4. Cuttlefish Virtual Android Devices.| (s. f.). Android Open Source Project.|<a href="https://source.android.com/setup/create/cuttlefish">Enlace a la pagina</a>
5. Chirammal, H. D., Mukhedkar, P., & Vettathu, A. (2016). | Mastering KVM Virtualization.| Packt Publishing. |<a href="https://www.packtpub.com/product/mastering-kvm-virtualization-second-edition/9781838828714">Enlace al libro</a>
