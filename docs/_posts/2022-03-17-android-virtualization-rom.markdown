---
layout: post
title:  "Virtualizacion a nivel de plataforma en Dispositivo Android"
date:   2022-03-17 07:19:16 +0000
categories: virtualization android
---

**Palabras Claves:** KVM, AOSP, Linux Kernel, QEMU, CrosVM, Cuttlefish device, Cross-Compile, Virtualizacion anidada.

<p style="text-align:justify;"><b>Abstracto:</b> Durante las últimas décadas se ha vuelto popular el uso de tecnologías basadas en la virtualización, esto debido a las diversas ventajas que surgen al distribuir las funciones de una máquina física entre varios usuarios o entornos. Entre estas ventajas destacan el aprovechamiento de toda la capacidad de la máquina, la creación de entornos aislados, personalizados y seguros, la división independiente de tareas para mejorar la eficiencia, sin mencionar que se considera a la virtualización como la base de tecnologías basadas en la nube (Cloud Computing). Una de las tecnologías que posibilitan la virtualización son los hipervisores, los cuales son un tipo de software que separa los recursos físicos de los entornos virtuales que los necesitan, posteriormente dichos recursos los dividen de manera tal que los entornos virtuales puedan utilizarlos. La mayoría de empresas hacen uso de virtualización con hipervisores para controlar Sistemas Operativos o para instalarse directamente en el hardware. Uno de los hipervisores mayormente utilizados en la actualidad es KVM (Máquina Virtual basada en Kernel) el cual es Open Source y se encuentra integrado en el Kernel de Linux desde la versión 2.6 en adelante. Teniendo en cuenta que el Sistema Operativo Android para dispositivos móviles utiliza como base el kernel de linux, se puede pensar que este mismo hipervisor KVM puede ser utilizado para implementar servicios basados en virtualización utilizando como host plataformas móviles. Por tanto, en la presente investigación se pretende exponer conceptos, teoría y experimentos que permitan una virtualización a nivel de plataforma en un dispositivo móvil, con enfoque al uso del hipervisor KVM en Sistemas Operativos Android. Posteriormente se utilizan las máquinas virtuales para exponer aplicaciones reales que son de beneficio para uso cotidiano y empresarial.</p>
<br><br>

<h2 style="text-align:center;">INTRODUCCION</h2>
<p style="text-align:justify;">El crecimiento de las plataformas y dispositivos móviles durante la última década es exponencial. Para nosotros es fácil percibirlo teniendo en cuenta que forman parte de nuestro dia a dia, siendo estos de utilidad ya sea para aplicaciones cotidianas en materia de comunicación, planificación y entretenimiento; así como aplicaciones empresariales en materia de Marketing, Ventas, Organización, Análisis y resultados científicos entre otros. Los dispositivos móviles están en todas partes del mundo y en cada actividad que realizamos, por esa razón se dice que existe una aplicación móvil para todo. Es importante tener en cuenta que así como crecen los diversos campos de la ciencia de la misma forma cada día se desarrollan aplicaciones que requieren una mayor complejidad tanto lógica a nivel de software como física a nivel de hardware. Teniendo lo anterior en cuenta no es de extrañar que cada ciertos meses o años veamos surgir nuevas gamas de dispositivos con caracteristicas nuevas y en algunos casos con mayor potencia tecnica en comparacion a sus antecesores.</p>

<p style="text-align:justify;">Todas estas ventajas ofrecidas por los dispositivos móviles son en parte gracias al constante desarrollo de diversos Sistemas Operativos. Un Sistema Operativo es el programa más importante que se ejecuta en una computadora. Este se encarga de administrar procesos, memoria así como a otros programas y al hardware en general. También permite comunicarnos con una computadora sin la necesidad de saber el lenguaje de máquina. Es importante entender que un dispositivo móvil es como tal considerado una computadora, de hecho, todo software destinado para computadoras de escritorio, portátiles o servidores, sin duda alguna, puede ser programado para dispositivos móviles, la única diferencia está en las capacidades a nivel de hardware. En la actualidad destacan dos grandes Sistemas Operativos para dispositivos móviles, nos referimos al Sistema Operativo Android propiedad del gigante Google inc company y al Sistema Operativo Iphone de Apple inc company. Es improtante mencionar que los conceptos y prácticas en este artículo son realizadas con base al Sistema Operativo Android. Esto debido a que Android OS es un sistema de código abierto, por lo cual es de acceso libre para todos e incluso para uso comercial. Sin mencionar que Android OS por mucho es el Sistema Operativo más popular alrededor del mundo. Teniendo en cuenta que la base de Android OS es el kernel de linux esto permite que sea un sistema operativo multiplataforma ya que su implementación no se limita solamente a dispositivos móviles, por lo cual se abre una mayor variedad de posibilidades en comparación a otros Sistemas Operativos moviles.</p>

<br>
<h3>Android Open Source Project (AOSP)</h3>
<p style="text-align:justify;">Android es una pila de software de código abierto creada para una amplia gama de dispositivos con diferentes factores de forma. El objetivo principal de Android es crear una plataforma de software abierta disponible para operadores, fabricantes de equipos originales y desarrolladores para hacer realidad sus ideas innovadoras y presentar un producto exitoso del mundo real que mejore la experiencia móvil de los usuarios. Android está diseñado para que no haya un punto central de falla, donde un actor de la industria restringe o controla las innovaciones de otro. El resultado es un producto de consumo completo con calidad de producción con código fuente abierto para la personalización y la migración. En primer lugar, la filosofía de Android es pragmática. El objetivo es un producto compartido que cada colaborador pueda adaptar y personalizar. Por supuesto, la personalización descontrolada puede dar lugar a implementaciones incompatibles. Para evitar esto, el Proyecto de código abierto de Android (AOSP) mantiene el Programa de compatibilidad de Android, que explica en detalle lo que significa ser compatible con Android y lo que se requiere de los fabricantes de dispositivos para lograr ese estado. Cualquiera puede usar el código fuente de Android para cualquier propósito y todos los usos legítimos son bienvenidos. <a href="https://source.android.com/setup/intro">[1]</a></p>

<p style="text-align:justify;">El proyecto de código abierto AOSP permite a los desarrolladores estudiar y experimentar a fondo las distintas versiones de Android mediante un conjunto de repositorios que son identificados por etiquetas las cuales hacen referencia a la versión de Android a la que van destinados. Por ejemplo, suponiendo tal vez que por razones de capacidad o consumo, tu equipo de desarrollo está interesado en la implementación de sistemas utilizando Android 9 (pie), siendo esto cierto, es probable que tu equipo opte por utilizar la rama aosp-pie-gsi aunque existen diversas ramas relacionadas a una misma versión de Android pero con propósitos diferentes. Es importante mencionar que para trabajar con el código de estos repositorios, es requisito utilizar el sistema de control de versiones Git así como Repo, una herramienta administradora de repositorios desarrollada por Google y que trabaja sobre Git. Cada repositorio cuenta con un conjunto de herramientas que permiten la compilación y emulación de dispositivos Android. Por defecto AOSP nos proporciona el código fuente del kernel y las especificaciones binarias para poder compilar algunos dispositivos específicos tales como Nexus y Pixel. También podemos crear compilaciones para placas tales como DragonBoard 845c, HiKey 960, Khadas VIM3 y Qualcomm Robotics Board RB5. Otra opción que AOSP nos proporciona en cuanto a la compilación de dispositivos es el uso de Imágenes de Sistema Genérico (GSI) la cual se ajusta a las configuraciones de dispositivos Android. En caso de que contemos con el código fuente (kernel) de algún dispositivo Android que no se encuentra en la lista del repositorio, AOSP nos brinda las herramientas necesarias para poder agregar un nuevo dispositivo, por ejemplo un Xperia Z, dispositivo sobre el cual precisamente existe una documentación de cómo compilarlo utilizando AOSP mediante el código fuente de uso abierto proporcionado por Sony. Por último se hace mención a los dispositivos Cuttlefish, un tipo de dispositivo agregado desde la versión 9 de Android hasta la actualidad y que ofrece una gran variedad de ventajas en comparación a otros tipos de dispositivos, como por ejemplo el tipo de emulación que lo caracteriza. Cuttlefish es un dispositivo Android virtual configurable que puede ejecutarse tanto de forma remota (usando ofertas de nube de terceros como Google Cloud Engine) como localmente (en máquinas Linux x86). Cuttlefish garantiza la fidelidad total con el marco de trabajo de Android (ya sea AOSP puro o una implementación personalizada en nuestro propio árbol). En la aplicación del mundo real, esto significa que debemos esperar que Cuttlefish responda a interacciones en el nivel del sistema operativo tal cual como lo haría un teléfono físico creado con la misma fuente de sistema operativo Android pura o personalizada. Para las prácticas realizadas en este artículo se utiliza un dispositivo Cuttlefish de la rama gsi de Android 11, en específico, el dispositivo <code>aosp_cf_x86_phone</code> perteneciente a la rama <code>aosp-android11-gsi</code>.
</p><br>
<h4>Capas de compilacion</h4>
<p style="text-align:justify;">La jerarquía de compilación incluye capas de abstracción que corresponden a la composición física de un dispositivo: <a href="https://source.android.com/setup/develop/new-device#build-layers">[2]</a></p>
- **La capa del producto** define la especificación de funciones de un producto de envío, como los módulos que se van a construir, las configuraciones regionales admitidas y la configuración para varias configuraciones regionales. En otras palabras, este es el nombre del producto en general. Las variables específicas del producto se definen en archivos MAKE de definición de producto. Entre algunos ejemplos tenemos a ```myProduct```, ```myProduct_eu```, ```myProduct_eu_fr```, ```j2```, ```sdk```.
- **La capa de placa/dispositivo** representa la capa física de plástico en el dispositivo (es decir, el diseño industrial del dispositivo). Esta capa también representa los esquemas básicos de un producto. Estos incluyen los periféricos en la placa y su configuración. Los nombres utilizados son simplemente códigos para diferentes configuraciones de placa/dispositivo. Entre algunos ejemplos tenemos a ```marlin```, ```blueline```, ```coral```.
- **La capa de arquitectura** describe la configuración del procesador y la interfaz binaria de la aplicación (ABI) que se ejecutan en la placa. Entre algunos ejemplos tenemos a ```arm```, ```x86```, ```arm64```, ```x86_64```.

<br>
<h4>Sistema de compilacion</h4>
<p style="text-align:justify;">Es importante mencionar que en los repositorios AOSP nos podemos encontrar con dos sistemas de compilación diferentes. El primero es GNU Make, una herramienta la cual controla la generación de ejecutables y otros programas que no pertenecen al código fuente pero que si son requeridos por otros archivos fuentes. GNU Make compila los programas a partir de un archivo llamado makefile, que enumera cada uno de los archivos que no son fuente y los procesa a partir de otros archivos. El sistema de compilación GNU Make lo encontramos en versiones anteriores a Android 7 dentro del proyecto AOSP. El segundo es Soong, introducido a partir de Android 7.0 (Nougat) para reemplazar a make. Aprovecha la herramienta de clonación Kati GNU Make y el componente del sistema de compilación Ninja para acelerar las compilaciones de Android. Soong es el reemplazo del antiguo sistema de compilación basado en make de Android. Reemplaza los archivos Android.mk con archivos Android.bp, que son descripciones declarativas simples similares a JSON de los módulos para compilar. Hacer distinción entre ambos tipos de sistemas es clave en caso de que se desee implementar un marco de trabajo personalizado, otra razón a tener en cuenta es la diferencia en el consumo de recursos que requiere cada sistema. De una forma empírica y basándonos en los experimentos realizados por el equipo de trabajo, se confirmó que las últimas versiones en AOSP (7 en adelante) tienden a consumir mas del doble de recursos que sus antecesoras, esto en parte debido al sistema de compilado, por ejemplo, la rama master (ultima estable) publicada hasta el momento, hace referencia a Android 13 (tiramisu) sobre la cual se confirmó un consumo por encima de los 12GB de ram durante el proceso de compilado; Una notable diferencia en comparación al compilado de la versión 7.1.2 (Nougat) de la cual se registró un consumo por debajo de los 4GB de ram.</p>

<br>
<h4>Tipos de Emuladores</h4>
<p>Actualmente en AOSP destacan dos formas de emular dispositivos android; La forma mas comun es por medio de un Emulador Android de Dispositivos Virtuales (AVD). Android Emulator nos permite ejecutar emulaciones de dispositivos Android en máquinas con Windows, macOS o Linux. El emulador de Android ejecuta el sistema operativo Android en una máquina virtual llamada dispositivo virtual de Android (AVD). El AVD contiene una pila completa de software de Android y se ejecuta como si estuviera en un dispositivo físico. <a href="https://source.android.com/setup/create/avd">[3]</a></p>
<p style="text-align:center;">Figura 1</p>
<img src="https://raw.githubusercontent.com/martulioruiz/my_blog/main/docs/assets/emulator-design.png" style="display: block; margin-left: auto; margin-right: auto; width: 50%;">
<p style="text-align:center; "><i>Nota. Arquitectura AVD, (s. f.). Android Open Source Project.</i></p>
<p style="text-align:justify;">La segunda forma es por medio de Dispositivos Virtuales Android Cuttlefish (CVD), como se menciono anteriormente Cuttlefish es un dispositivo Android virtual configurable que puede ejecutarse tanto de forma remota (usando ofertas de nube de terceros como Google Cloud Engine) como localmente (en máquinas Linux x86). Hay muchas similitudes con el emulador de Android, pero Cuttlefish garantiza una fidelidad total con el marco de trabajo de Android (ya sea AOSP puro o una implementación personalizada en su propio árbol). En la aplicación del mundo real, esto significa que debemos esperar que Cuttlefish responda a sus interacciones en el nivel del sistema operativo como un objetivo de teléfono físico creado con la misma fuente de sistema operativo Android pura o personalizada. El emulador de Android se ha creado en torno al caso de uso de facilitar el desarrollo de aplicaciones y contiene muchos ganchos funcionales para atraer los casos de uso del desarrollador de aplicaciones de Android. Esto puede presentar desafíos si el objetivo es crear un emulador con marco de Android personalizado. Para los casos en que se  necesita un dispositivo virtual que sea representativo para una plataforma/código de marco personalizado o arbol de Android, entonces Cuttlefish es una opción virtual ideal. Es el dispositivo canónico para representar el estado actual del desarrollo de AOSP. Uno de los aspectos importantes a destacar sobre los dispositivos cuttlefish es que son dispositivos Android que pueden ser utilizados para depurar. Se pueden registrar a si mismos como un dispositvo normal via ADB y se puede interactuar con ellos como si fuesen un dispositivo fisico por medio de Escritorios remotos.<a href="https://source.android.com/setup/create/cuttlefish">[4]</a></p>
<p style="text-align:center;">Figura 2</p>
<img src="https://raw.githubusercontent.com/martulioruiz/my_blog/main/docs/assets/cf.png" style="display: block; margin-left: auto; margin-right: auto; width: 50%;">
<p style="text-align:center; "><i>Nota. Dispositivo Virtual Cuttlefish renderizado via Webrt.</i></p>
<br>
<h4>Integracion Continua de Android</h4>
<p style="text-align:justify;">Teniendo en cuenta que el equipo de desarrollo se centró en realizar pruebas principalmente en el dispositivo virtual Cuttlefish <code>aosp_cf_x86_phone</code> perteneciente a la rama <code>aosp-android11-gsi</code> consideramos importante mencionar el procedimiento que se siguió para escoger este dispositivo en particular entre una gran variedad de opciones disponibles; Si bien, la idea principal era compilar un dispositivo perteneciente a la última versión de Android y emularlo. A pesar de que se logró compilar con éxito este no se logró emular correctamente. La razón del fallo era que se estaba intentado emular localmente un dispositivo cuttlefish de arquitectura x86_64; Tomando como referencia la documentación oficial de AOSP, localmente solamente son soportados los dispositivos de arquitectura x86. Este descubrimiento se logró luego de muchas compilaciones de diferentes dispositivos al azar en todas las ramas principales. Como consecuencia se consumió una gran cantidad de tiempo en lo que terminaba de compilarse cada dispositivo. Además de la arquitectura se encontraron otras razones por las cuales algunos dispositivos en específico no se emulaban con éxito, la mayoría de estos problemas estaban relacionados con requisitos e incompatibilidades de hardware en el sistema operativo host. Teniendo en cuenta lo anterior se podría decir que era una tarea tediosa encontrar dispositivos que funcionaran correctamente en la máquina host de cada integrante del equipo, principalmente debido a que el compilado tardaba horas en finalizar. Afortunadamente Google nos proporciona una solución de integración continua (Android CI) que nos permite tener acceso a distintos artefactos de dispositivos ya compilados. Entre  estos artefactos se encuentran archivos de imágenes y herramientas de host cuttlefish necesarios para una correcta emulación. Si bien estos artefactos se generaban al compilar los dispositivos, mediante Android CI se lograban obtener en cuestión de minutos dependiendo de la velocidad de descarga de nuestro internet. Por tanto mediante Android CI se obtuvieron los artefactos de diversos dispositivos cuttlefish y estos posteriormente se utilizaron para realizar pruebas hasta encontrar el dispositivo que mejor se ajustaba a nuestro entorno, resultando como mejor opción el dispositivo aosp_cf_x86_phone de la rama aosp-android11-gsi.
</p>
<br>

<h3>Virtualizacion</h3>
<p style="text-align:justify;">El proyecto final correspondiente a este articulo tiene como tematica principal la Virtualizacion, en especifico, explorar aplicaciones reales de virtualizacion en dispositivos android. Por esta razon introducimos algunos conceptos escenciales sobre la virtualizacion y puntos importantes a tomar en cuenta para enriquecer la practica.</p>
<p style="text-align:justify;">La virtualización es una tecnología que nos permite crear múltiples entornos simulados o recursos dedicados desde un único sistema de hardware físico. Su base es un software llamado hipervisor el cual se conecta directamente al hardware y nos permite dividir un sistema en entornos separados, distintos y seguros conocidos como máquinas virtuales (VM). Estas máquinas virtuales dependen de la capacidad del hipervisor para separar los recursos de la máquina del hardware y distribuirlos adecuadamente. El hardware físico, equipado con un hipervisor, se denomina host, mientras que las numerosas máquinas virtuales que utilizan sus recursos son invitados (guests). Estos invitados tratan los recursos informáticos, como la CPU, la memoria y el almacenamiento, como un conjunto de recursos que se pueden reubicar fácilmente. Los operadores pueden controlar instancias virtuales de CPU, memoria, almacenamiento y otros recursos, para que los invitados reciban los recursos que necesitan cuando los necesitan. <a href="https://www.redhat.com/en/topics/virtualization">[5]</a>
</p>
<br>

<h4>Diferencias entre Emulacion y Virtualizacion</h4>
<p style="text-align:justify;">La emulación, en definitiva, consiste en hacer que un sistema imite a otro. Por ejemplo, si una pieza de software se ejecuta en el sistema A y no en el sistema B, hacemos que el sistema B "emule" el funcionamiento del sistema A. El software luego se ejecuta en una emulación del sistema A. En este mismo ejemplo, la virtualización implicaría tomar el sistema A y dividirlo en dos servidores, B y C. Ambos servidores "virtuales" son contenedores de software independientes, que tienen su propio acceso a recursos basados ​​en software: CPU, RAM, almacenamiento y redes. – y se puede reiniciar de forma independiente. Se comportan exactamente como el hardware real, y una aplicación u otra computadora no podrían notar la diferencia. La emulación se puede utilizar de manera efectiva en los siguientes escenarios: <a href="https://www.dell.com/en-us/blog/emulation-or-virtualization-what-s-the-difference">[6]</a>
</p>
- Ejecutar un sistema operativo diseñado para otro hardware (por ejemplo, software de Mac en una PC; juegos basados ​​en consola en una computadora).
- Ejecutar software destinado a otro sistema operativo (ejecutar software específico de Mac en una PC y viceversa).
- Ejecución de software heredado después de que el hardware comparable se vuelva obsoleto.

<p style="text-align:justify;">Mientras que los entornos que son emulados requieren un puente de software para interactuar con el hardware, la virtualización accede directamente al hardware. Sin embargo, a pesar de ser la opción más rápida en general, la virtualización se limita a ejecutar software que ya podía ejecutarse en el hardware subyacente. Los beneficios más claros de la virtualización incluyen: <a href="https://www.dell.com/en-us/blog/emulation-or-virtualization-what-s-the-difference">[6]</a></p>
- Amplia compatibilidad con la arquitectura de CPU x86 existente.
- Capacidad de aparecer como dispositivos físicos para todo el hardware y software.
- Autónomo en cada caso.

<br>

<h4>Maquinas Virtuales Basadas En Kernel</h4>
<p style="text-align:justify;">Las máquinas virtuales basadas en kernel (KVM) representan la última generación de tecnologias de virtualización de codigo abierto. El objetivo del proyecto era crear un hipervisor moderno que se basara en la experiencia de tecnologías pertenecientes a generaciones anteriores y que aprovechara el hardware moderno disponible en la actualidad (VT-x, AMD-V). KVM convierte el kernel de Linux en un hipervisor al instalar el modulo del nucleo KVM. Siendo el hipervisor el kernel estándar de Linux, este se beneficia de los cambios al núcleo estándar (soporte de memoria, planificador, etc.). Optimizaciones para estos componentes de Linux (como el nuevo planificador en el kernel 3.1) benefician tanto al hipervisor (el sistema operativo host) como a los sistemas operativos invitados de Linux. Para las emulaciones de E/S, KVM utiliza un software de usuario llamado QEMU; Qemu es un programa de usuario que hace emulación de hardware. Este se encarga de emular el procesador y una larga lista de dispositivos periféricos: disco, red, VGA, PCI, USB, puertos seriales/paralelos, etc. para construir un hardware virtual completo en el que se pueda instalar el sistema operativo invitado y asi ser emulado por KVM. Formalmente QEMU es un emulador y virtualizador de máquinas genérico y de código abierto. Cuando se usa como emulador de máquina, QEMU puede ejecutar sistemas operativos y programas creados para una máquina (por ejemplo: una placa ARM) en una máquina diferente (por ejemplo: su propia PC). Por medio de la traducción dinámica, logra un buen rendimiento. <a href="https://www.packtpub.com/product/mastering-kvm-virtualization-second-edition/9781838828714">[7]</a></p>
<br>

<h3>Kernel de Linux</h3>
<p style="text-align:justify;">A pesar de su enorme codigo base (más de siete millones de líneas de código), el kernel de Linux es el sistema operativo más flexible que jamás se haya creado. Se puede ajustar para una amplia gama de sistemas diferentes, que se ejecutan en todo, desde un control por radio para un modelo de helicóptero, a un teléfono celular y a la mayoría de supercomputadoras más grandes en el mundo. Al personalizar el núcleo para nuestro entorno específico, es posible crear algo que es más pequeño y rápido que el núcleo proporcionado por la mayoría de las distribuciones de Linux. Ninguna distribución de Linux proporciona el kernel exacto que la mayoría de sus usuarios desean. Las distribuciones modernas se han vuelto muy complacientes, recopilando soporte para cada
dispositivo conocido, para el sonido, e incluso para la conservación de energía. Pero es probable que se tenga una necesidad diferente a la de la mayoría de los usuarios (ya que cada distribución tiende a tratar de satisfacer las necesidades de la mayoría) como por ejemplo tener un hardware diferente. Cuando sale un nuevo kernel, es probable tambien que deseemos comenzar a usarlo sin esperar a que se construya una distribución a su alrededor. Tambien, existen muy buenas razones para eliminar funciones del núcleo, especialmente si se está ejecutando en un sistema integrado o en uno con factor de forma pequeño. <a href="http://www.kroah.com/lkn/">[8]</a></p>

<br><br>
<h2 style="text-align:center;">BIBLIOGRAFIAS</h2>
1. Set up for Android Development. | (s. f.). Android Open Source Project. |<a href="https://source.android.com/setup/intro">Enlace a la pagina</a>
2. Adding a New Device.|(s. f.). Android Open Source Project.|<a href="https://source.android.com/setup/develop/new-device#build-layers">Enlace a la pagina</a> 
3. Using Android Emulator Virtual Devices.| (s. f.). Android Open Source Project.|<a href="https://source.android.com/setup/create/avd">Enlace a la pagina</a>
4. Cuttlefish Virtual Android Devices.| (s. f.). Android Open Source Project.|<a href="https://source.android.com/setup/create/cuttlefish">Enlace a la pagina</a>
5. Understanding virtualization.|(s. f.). Red Hat.|<a href="https://www.redhat.com/en/topics/virtualization">Enlace a la pagina</a> 
6. Dell Technologies Blog.|Emulation or virtualization: What’s the difference?.|13 de marzo de 2014.|<a href="https://www.dell.com/en-us/blog/emulation-or-virtualization-what-s-the-difference">Enlace a la pagina</a> 
7. Chirammal, H. D., Mukhedkar, P., & Vettathu, A. (2016). | Mastering KVM Virtualization.| Packt Publishing. |<a href="https://www.packtpub.com/product/mastering-kvm-virtualization-second-edition/9781838828714">Enlace al libro</a>
8. Kroah-Hartman, G. (2007).| Linux Kernel in a Nutshell.| Van Duuren Media.|<a href="http://www.kroah.com/lkn/">Enlace al libro</a>

